---
title: "Annotation for differential expression analysis"
author: "Marta Perez Alcantara"
date: "6 de octubre de 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r libraries and data, include=FALSE}
library(biomaRt)
library(GOstats)

# import files for DE results for every stage

sig_iPSC_stage= read.csv("/Users/Marta/Documents/WTCHG/DPhil/Data/Results/Diff_v2/Voom/conservative_counts/2016-10-05_sig_maxvals_iPSC_diff_expression_results.csv")
sig_DE_stage= read.csv("/Users/Marta/Documents/WTCHG/DPhil/Data/Results/Diff_v2/Voom/conservative_counts/2016-10-05_sig_maxvals_DE_diff_expression_results.csv")
sig_PGT_stage= read.csv("/Users/Marta/Documents/WTCHG/DPhil/Data/Results/Diff_v2/Voom/conservative_counts/2016-10-05_sig_maxvals_PGT_diff_expression_results.csv")
sig_PFG_stage= read.csv("/Users/Marta/Documents/WTCHG/DPhil/Data/Results/Diff_v2/Voom/conservative_counts/2016-10-05_sig_maxvals_PFG_diff_expression_results.csv")
sig_PE_stage= read.csv("/Users/Marta/Documents/WTCHG/DPhil/Data/Results/Diff_v2/Voom/conservative_counts/2016-10-05_sig_maxvals_PE_diff_expression_results.csv")
sig_EP_stage= read.csv("/Users/Marta/Documents/WTCHG/DPhil/Data/Results/Diff_v2/Voom/conservative_counts/2016-10-05_sig_maxvals_EP_diff_expression_results.csv")
sig_EN6_stage= read.csv("/Users/Marta/Documents/WTCHG/DPhil/Data/Results/Diff_v2/Voom/conservative_counts/2016-10-05_sig_maxvals_EN6_diff_expression_results.csv")
sig_EN7_stage= read.csv("/Users/Marta/Documents/WTCHG/DPhil/Data/Results/Diff_v2/Voom/conservative_counts/2016-10-05_sig_maxvals_EN7_diff_expression_results.csv")

 
# import dge object


load(file="/Users/Marta/Documents/WTCHG/DPhil/Data/Diff_v2/session_objects/dge_cc.xz",verbose=TRUE)  #loading the dge object for conservative counts


```

## Gene ontology annotation

TheGOstats package has extensive facilities for testing the association of Gene Ontology (GO) The Gene Ontology Consortium (2000) terms to genes in a gene list. You can test for both over and under representation of GO terms using either the standard Hypergeometric test or a conditional Hypergeometric test that uses the relationships among the GO terms for conditioning (similar to that presented in Alexa et al. (2006)).

To perform an analysis using the Hypergeometric-based tests, one needs to define a gene universe (usually conceptualized as the number of balls in an urn) and a list of selected genes from the universe. While it is clear that the selected gene list determines to a large degree the results of the analysis, the fact that the universe has a large effect on the conclusions is,
perhaps, less obvious.

It is worth noting that the effect of increasing the universe size with genes that are irrelevant to the questions at hand, in general, has the effect of making the resultant p-values look more significant. For example, in a universe of 1000 genes where 400 have been selected, suppose that a GO term has 40 gene annotations from the universe of 1000. If 10 of the genes in the selected gene list are among the 40 genes annotated at this category, then the Hypergeometric p-value is 0.99. However, if the gene universe contained 5000 genes, the p-value would drop to 0.001.
```{r cars}


#perform GO enrichment using GOstats
#calculate q-values for enrichment results
ensembl <- useMart("ENSEMBL_MART_ENSEMBL",dataset="hsapiens_gene_ensembl",host="www.ensembl.org")

##get the entrez IDs for the genes of interest. Takes Ensembl gene ids from my data
all_ensembl_to_entrez <- getBM(attributes=c('ensembl_gene_id', 'entrezgene'), 
                                filters = 'ensembl_gene_id', 
                                values = rownames(dge_cc), mart = ensembl)  # all genes from dge object
sig_iPSC_ensembl_to_entrez <- getBM(attributes=c('ensembl_gene_id', 'entrezgene'), 
                                filters = 'ensembl_gene_id', 
                                values = sig_iPSC_stage$ensembl_gene_id, mart = ensembl)
sig_DE_ensembl_to_entrez <- getBM(attributes=c('ensembl_gene_id', 'entrezgene'), 
                                filters = 'ensembl_gene_id', 
                                values = sig_DE_stage$ensembl_gene_id, mart = ensembl)
sig_PGT_ensembl_to_entrez <- getBM(attributes=c('ensembl_gene_id', 'entrezgene'), 
                                filters = 'ensembl_gene_id', 
                                values = sig_PGT_stage$ensembl_gene_id, mart = ensembl)
sig_PFG_ensembl_to_entrez <- getBM(attributes=c('ensembl_gene_id', 'entrezgene'), 
                                filters = 'ensembl_gene_id', 
                                values = sig_PFG_stage$ensembl_gene_id, mart = ensembl)
sig_PE_ensembl_to_entrez <- getBM(attributes=c('ensembl_gene_id', 'entrezgene'), 
                                filters = 'ensembl_gene_id', 
                                values = sig_PE_stage$ensembl_gene_id, mart = ensembl)
sig_EP_ensembl_to_entrez <- getBM(attributes=c('ensembl_gene_id', 'entrezgene'), 
                                filters = 'ensembl_gene_id', 
                                values = sig_EP_stage$ensembl_gene_id, mart = ensembl)	
sig_EN6_ensembl_to_entrez <- getBM(attributes=c('ensembl_gene_id', 'entrezgene'), 
                                filters = 'ensembl_gene_id', 
                                values = sig_EN6_stage$ensembl_gene_id, mart = ensembl)	
sig_EN7_ensembl_to_entrez <- getBM(attributes=c('ensembl_gene_id', 'entrezgene'), 
                                filters = 'ensembl_gene_id', 
                                values = sig_EN7_stage$ensembl_gene_id, mart = ensembl)	

# there are entrez gene IDS for more than one ensembl id, and at the same time there are ensembl ids without entrez gene ids.

# results: data frame with ensembl_gene_id and entrez gene id

##Get the entrez gene identifiers that are mapped to a GO ID
entrez_object <- org.Hs.egGO
mapped_genes <- mappedkeys(entrez_object) # all entrez keys that have GO id
all_with_go <- unique(intersect(all_ensembl_to_entrez$entrezgene,mapped_genes)) # all entrez ids that have GO id from dge object
sig_iPSC_with_go <- unique(intersect(sig_iPSC_ensembl_to_entrez$entrezgene,mapped_genes)) # now for every sig DEA results
sig_DE_with_go <- unique(intersect(sig_DE_ensembl_to_entrez$entrezgene,mapped_genes))
sig_PGT_with_go <- unique(intersect(sig_PGT_ensembl_to_entrez$entrezgene,mapped_genes))
sig_PFG_with_go <- unique(intersect(sig_PFG_ensembl_to_entrez$entrezgene,mapped_genes))
sig_PE_with_go <- unique(intersect(sig_PE_ensembl_to_entrez$entrezgene,mapped_genes))
sig_EP_with_go <- unique(intersect(sig_EP_ensembl_to_entrez$entrezgene,mapped_genes))
sig_EN6_with_go <- unique(intersect(sig_EN6_ensembl_to_entrez$entrezgene,mapped_genes))
sig_EN7_with_go <- unique(intersect(sig_EN7_ensembl_to_entrez$entrezgene,mapped_genes))

##run the hypergeometric test on GO biological process
#iPSC
params <- new('GOHyperGParams',
              geneIds=sig_iPSC_with_go,  # list of genes I'm testing
              universeGeneIds=all_with_go, # list of genes I used in my DE analysis (all my genes with RNA-seq data)
              ontology='BP',
              pvalueCutoff=0.01,  # p value <0.01
              conditional=T,
              testDirection='over',
              annotation="org.Hs.eg.db"
             )
hgOver <- hyperGTest(params)
hgOver  

# Printing the result at the R prompt provides a brief summary of the test performed and the number of significant terms found. Depending on how you pre-processed your gene list and gene universe, The hyperGTest function may have to do even more filtering
# on both of these for you. Genes that are not marked with a GO term from the ontology that you specified will have to be discarded, and so you might notice that your gene list and gene universe had shrank somewhat when you print the results.

result <- summary(hgOver)
result <- result[which(result$Size > 1 & result$Count > 1),]
##calculate qvalues
result <- cbind(result,Qvalue=qvalue(result$Pvalue)$qvalue)
write.table(file="GOstats_GO_BP_iPSC.result.tsv",result,quote=F,sep="\t",row.names=F)

```
